# 全体構成：リファクタリング第2版

## 書籍アーキテクチャ

第2版は1999年の原著の完全書き直しであり、初版を革命的にした基本原則を保持しながら、現代のJavaScript開発向けに現代化されている。

### 第I部：基礎と例（第1-5章）
**目的**：JavaScript例による現代的リファクタリング原則の確立

#### 第1章：リファクタリング、最初の例
- **現代のビデオ店**: ES6+機能を使用したJavaScript実装
- **段階的プロセス**: 現代のリファクタリングワークフローの実演
- **テスト統合**: 現代的JavaScriptテストフレームワーク
- **ツールサポート**: 現在の開発環境との統合

#### 第2章：リファクタリングの原則
- **更新された定義**: 20年の経験によって洗練されたリファクタリング定義
- **現代の経済学**: アジャイルおよびDevOpsコンテキスト向けに更新されたビジネスケース
- **現代的タイミング**: 現代の開発サイクルでのリファクタリング時期
- **現在の課題**: パフォーマンス、セキュリティ、規模に関する今日の懸念への対処

#### 第3章：コードの不吉な臭い
- **古典的臭い**: JavaScript例による伝統的コード臭い
- **現代的アンチパターン**: 現代プログラミングに関連する新しい臭い
- **Web開発臭い**: フロントエンドおよびAPI固有のアンチパターン
- **フレームワーク考慮事項**: 現代JavaScriptフレームワーク固有の臭い

#### 第4章：テストの構築
- **JavaScriptテスト**: 現代的テストフレームワークと実践
- **テストファーストリファクタリング**: TDDアプローチの強化された強調
- **非同期テスト**: async/awaitとPromiseベースコードのテスト
- **統合テスト**: 統合およびエンドツーエンドテストへの現代的アプローチ

#### Chapter 5: Introducing the Catalog
- **合理化されたフォーマット**: ユーザーフィードバックに基づく改善された組織化
- **現代的参照**: 現代のリソースとツールへのリンク
- **ツール統合**: IDE機能とのより良い整合性
- **オンラインリソース**: Webベースドキュメントと例への接続

### 第II部：リファクタリングカタログ（第6-12章）
**目的**：変換タイプによって組織化された包括的技法

#### 第6章：第一のリファクタリング群
**基本変換**: JavaScript向けに更新された基本的リファクタリング技法
- 関数の抽出（Extract Methodから現代化）
- 関数のインライン化（アロー関数で更新）
- 変数の抽出（const/let考慮事項）
- 変数の名前変更（IDE統合）
- パラメータオブジェクトの導入（分割代入サポート）
- 関数のクラスへの結合（ES6クラス）
- 関数の変換への結合（関数型アプローチ）
- フェーズの分離（パイプライン処理）

#### 第7章：カプセル化
**データ保護**: データカプセル化への現代的アプローチ
- レコードのカプセル化（オブジェクトリテラルとクラス）
- コレクションのカプセル化（配列とMap/Set処理）
- プリミティブをオブジェクトに置き換え（JavaScript型考慮事項）
- 一時変数をクエリに置き換え（const/letスコープ）
- クラスの抽出（モジュール組織化）
- クラスのインライン化（モジュール単純化）
- 委譲の隠蔽（インターフェース設計）
- 仲介人の除去（直接アクセスパターン）
- アルゴリズムの置き換え（関数型代替）

#### 第8章：機能の移動
**コード組織化**: 機能配置と組織化
- 関数の移動（モジュールとクラス組織化）
- フィールドの移動（プロパティ組織化）
- ステートメントの関数内移動（コード統合）
- ステートメントの呼び出し側移動（責任分散）
- インラインコードを関数呼び出しに置き換え（再利用性）
- ステートメントのスライド（コード配置）
- ループの分離（関数型プログラミング影響）
- ループをパイプラインに置き換え（配列メソッド）

#### 第9章：データの組織化
**データ構造管理**: 現代的データ処理アプローチ
- 変数の分離（const使用）
- フィールドの名前変更（プロパティ命名）
- 派生変数をクエリに置き換え（計算プロパティ）
- 参照を値に変更（不変性考慮事項）
- 値を参照に変更（オブジェクト同一性）

#### 第10章：条件記述の単純化
**意思決定**: よりクリーンな条件構造
- 条件記述の分解（関数抽出）
- 条件式の統合（ブール論理）
- ネストした条件をガード節に置き換え（早期リターン）
- 条件をポリモーフィズムに置き換え（クラス階層）
- 特殊ケースの導入（nullオブジェクトパターン）
- アサーションの導入（検証ロジック）

#### 第11章：APIのリファクタリング
**インターフェース設計**: API進化と改善
- 問い合わせと変更の分離（副作用管理）
- 関数のパラメータ化（設定パターン）
- フラグ引数の除去（明示的メソッド）
- オブジェクト全体の保持（パラメータ削減）
- パラメータをクエリに置き換え（依存注入）
- クエリをパラメータに置き換え（分離）
- 設定メソッドの除去（不変性）
- コンストラクタをファクトリ関数に置き換え（作成パターン）
- 関数をコマンドに置き換え（複雑操作）
- コマンドを関数に置き換え（単純化）

#### 第12章：継承の扱い
**オブジェクト指向設計**: クラス階層管理
- メソッドの引き上げ（共通動作）
- フィールドの引き上げ（共有データ）
- コンストラクタ本体の引き上げ（初期化）
- メソッドの押し下げ（特殊化動作）
- フィールドの押し下げ（特定データ）
- タイプコードをサブクラスに置き換え（ポリモーフィズム）
- サブクラスの除去（単純化）
- スーパークラスの抽出（共通抽象化）
- 階層の平坦化（不要な複雑性）
- サブクラスを委譲に置き換え（継承より合成）
- スーパークラスを委譲に置き換え（依存関係逆転）

## 初版からの主要構造的違い

### 言語進化
- **JavaScriptフォーカス**: 現代JavaScript（ES6+）のすべての例
- **関数型要素**: 関数型プログラミング概念の組み込み
- **非同期パターン**: 非同期コードとPromiseの処理
- **モジュールシステム**: ES6モジュールとコード組織化

### カタログ洗練
- **合理化された技法**: 陳腐化したリファクタリングの除去
- **新しいパターン**: 現代プログラミングパターンの追加
- **より良い組織化**: 改善されたグループ化と相互参照
- **実用的フォーカス**: 一般的に使用される技法の強調

### 現代的コンテキスト
- **Web開発**: フロントエンドとバックエンドJavaScript考慮事項
- **フレームワーク統合**: React、Vue、Angularパターン
- **パフォーマンス**: 現代JavaScriptパフォーマンス考慮事項
- **ツール**: 現代開発ツールとの統合

## 教育進行

### 学習パス1：JavaScript開発者
1. 馴染みのあるJavaScriptでの第1章例から開始
2. 現代的コンテキストでの第2章原則の理解
3. 第3章での臭いの識別学習
4. 現在のフレームワークでの第4章テストの習得
5. カタログ第6-12章の体系的取り組み

### 学習パス2：経験豊富な開発者（初版背景）
1. 第1章を元のJava例と比較
2. 第2章での原則更新の注記
3. 第3章での新しい臭いの識別
4. 第4章でのJavaScriptへのテスト知識の適応
5. カタログでの新しいおよび変更されたリファクタリングに焦点

### 学習パス3：チーム実装
1. チーム標準のための第2章原則の使用
2. 第3章臭いからの共有語彙作成
3. 第4章からのテスト実践の確立
4. カタログからのリファクタリングの段階的実装
5. 開発ワークフローへのリファクタリングの構築

## 現代開発との統合

### 開発ワークフロー
- **継続的統合**: CI/CDパイプラインでのリファクタリング
- **コードレビュー**: ピアレビュープロセスの一部としてのリファクタリング
- **ペアプログラミング**: 協働リファクタリングセッション
- **ドキュメント**: リファクタリングによる生きたドキュメント

### ツールエコシステム
- **IDE**: Visual Studio Code、WebStorm統合
- **静的解析**: ESLint、Prettier自動化
- **テスト**: Jest、Mocha、Cypress統合
- **バージョン管理**: リファクタリング変更のためのGitワークフロー

### 品質保証
- **自動テスト**: リファクタリング中の継続的テスト実行
- **パフォーマンス監視**: リファクタリング中の影響測定
- **コードメトリクス**: 品質測定と改善追跡
- **セキュリティ**: コード変換中のセキュリティ考慮

この構造は1999年以降のソフトウェア開発実践の進化を反映し、元の作品を非常に影響力あるものにした厳格で段階的なアプローチを維持しながら、体系的コード改善のための現代的基盤を提供している。