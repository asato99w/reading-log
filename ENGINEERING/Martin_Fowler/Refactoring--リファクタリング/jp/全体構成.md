# 全体構成：リファクタリング（初版）

## 書籍組織と文書化アプローチ

「リファクタリング」は、コード改善のマニフェストと包括的リファレンスカタログの両方として構成されている。本書は動機から原則を経て詳細なメカニクスへと進み、カタログが本書の中核を形成している。組織はファウラーの例による学習哲学を反映し、すべての概念が具体的なコードデモンストレーションに根ざしている。

## 主要部分と章構造

### 開始セクション：例による学習（第1章）
**目的**：理論を説明する前に実際のリファクタリングを実演

#### 第1章：リファクタリング、最初の例
- **開始点**：ビデオレンタル店の顧客明細を計算・印刷するプログラム
- **初期問題**：モノリシックメソッド、混在した関心事、修正困難
- **最初のリファクタリング**：明細メソッドの分解
- **責任の再配分**：適切なクラスへの振る舞い移動
- **条件ロジックの置換**：switch文の代わりにポリモーフィズム使用
- **最終構造**：新要件に対応可能な清潔で拡張可能な設計
- **学んだ教訓**：リファクタリングのリズムと規律

### 第I部：基礎と原則（第2-5章）
**目的**：リファクタリングの理論的・実践的基礎確立

#### 第2章：リファクタリングの原則
- **リファクタリング定義**：名詞と動詞の定義、設計との関係
- **なぜリファクタリングするか**：設計改善、ソフトウェア理解容易化、バグ発見支援、より速いプログラミング
- **いつリファクタリングするか**：3回ルール、機能追加時、バグ修正時、コードレビュー時
- **なぜリファクタリングしないか**：書き直しが良い場合、締切間近
- **リファクタリングと設計**：リファクタリングが設計プロセスを変える方法
- **リファクタリングとパフォーマンス**：なぜ清潔なコードが十分な性能を持つか
- **起源と歴史**：Smalltalkコミュニティ、オプダイクの論文、ツール開発

#### 第3章：コードの不吉な臭い
- **コード臭概念**：問題特定への直感使用
- **臭いカタログ**：22の特定コード臭
  - 重複コード：複数場所での同じ表現
  - 長いメソッド：多くをしようとするメソッド
  - 巨大クラス：責任が多すぎるクラス
  - 長いパラメータリスト：パラメータが多すぎるメソッド
  - 変更の発散：複数理由で変更されるクラス
  - その他17の臭いと推奨リファクタリング
- **臭いの関係**：臭いの関連と複合方法
- **リファクタリング対応**：どのリファクタリングがどの臭いに対処するか

#### 第4章：テストの構築
- **テスト基盤**：なぜテストがリファクタリングの前提条件か
- **自己テストコード**：自身の正しさを検証できるコード
- **JUnitフレームワーク**：Javaテストフレームワークの導入
- **テスト記述戦略**：既存コードへのテスト追加方法
- **テストカバレッジ**：どれだけのテストが十分か
- **テストファーストプログラミング**：TDDへの簡潔な導入
- **テストの課題**：データベース、UIなどの扱い

#### 第5章：リファクタリングカタログへ向けて
- **カタログ形式**：各リファクタリングの文書化方法
- **リファクタリングテンプレート**：
  - 名前：簡潔な説明
  - 要約：1行の要約
  - 動機：いつ、なぜ使用するか
  - メカニクス：段階的手順
  - 例：具体的実演
- **道を見つける**：カタログのナビゲート方法
- **技術詳細**：UML使用、コード規約
- **成熟度評価**：これらのリファクタリングの実証度

### 第II部：リファクタリングカタログ（第6-12章）
**目的**：特定リファクタリング技術の包括的リファレンス

#### 第6章：メソッドの構成
**テーマ**：コードを適切にメソッドにパッケージ化
- **メソッドの抽出**：断片を意味のある名前のメソッドに変換
- **メソッドのインライン化**：メソッド呼び出しをメソッド本体で置換
- **一時変数のインライン化**：一時変数を式で置換
- **一時変数を問い合わせメソッドで置換**：一時変数をメソッドで置換
- **説明用変数の導入**：式結果を意味のある名前の一時変数に入れる
- **一時変数の分割**：各代入に独自の一時変数
- **パラメータへの代入の除去**：代わりに一時変数使用
- **メソッドをメソッドオブジェクトで置換**：メソッドを独自オブジェクトに変換
- **アルゴリズムの代替**：アルゴリズムをより明確なもので置換

#### 第7章：オブジェクト間での機能移動
**テーマ**：責任がどこに存在すべきかの決定
- **メソッドの移動**：メソッドをより適切なクラスへ移動
- **フィールドの移動**：フィールドをより適切なクラスへ移動
- **クラスの抽出**：責任が多すぎるクラスを分割
- **クラスのインライン化**：あまり仕事をしないクラスをマージ
- **委譲の隠蔽**：クライアントが委譲を直接呼び出す
- **仲介者の除去**：クライアントが委譲を直接呼び出す
- **外部メソッドの導入**：修正できないクラスにメソッド追加
- **局所的拡張の導入**：修正できないクラスの拡張作成

#### 第8章：データの体系化
**テーマ**：データ作業を容易にする
- **フィールドの自己カプセル化**：フィールドアクセスにゲッター/セッター使用
- **データ値をオブジェクトで置換**：データ項目をオブジェクトに変換
- **値を参照へ変更**：オブジェクトを単一インスタンスに
- **参照を値へ変更**：オブジェクトを値オブジェクトに
- **配列をオブジェクトで置換**：配列を名前付きフィールドのオブジェクトで置換
- **観察データの複製**：プレゼンテーション用データをコピー
- **単方向を双方向へ変更**：バックポインタ追加
- **マジックナンバーを置換**：リテラルを名前付き定数で置換
- **フィールドのカプセル化**：フィールドをプライベートに、アクセサ追加
- **コレクションのカプセル化**：読み取り専用ビュー返却、追加/削除メソッド
- **タイプコードを置換**：タイプコードの複数技術
- **サブクラスをフィールドで置換**：データのみ異なるサブクラス削除

#### 第9章：条件記述の単純化
**テーマ**：条件ロジックをより明確で単純に
- **条件記述の分解**：条件部分からメソッド抽出
- **条件記述の統合**：同じ結果の条件を結合
- **重複する条件記述断片の統合**：共通コードを条件外へ移動
- **制御フラグの削除**：代わりにbreakまたはreturn使用
- **ネストした条件記述をガード節で置換**：早期リターン使用
- **条件記述をポリモーフィズムで置換**：条件分岐をサブクラスへ移動
- **ヌルオブジェクトの導入**：nullチェックをヌルオブジェクトで置換
- **表明の導入**：仮定を明示的に

#### 第10章：メソッド呼び出しの単純化
**テーマ**：インターフェースを理解・使用しやすくする
- **メソッド名の変更**：目的を明らかにする名前へ変更
- **パラメータの追加**：メソッドにパラメータ追加
- **パラメータの削除**：未使用パラメータ削除
- **問い合わせと更新の分離**：値を返すメソッドと状態を変更するメソッドを分離
- **メソッドのパラメータ化**：類似メソッドを1つのパラメータ化メソッドで置換
- **パラメータを明示的メソッドで置換**：パラメータを別々のメソッドで置換
- **オブジェクトそのものを保持**：値の代わりにオブジェクト全体を渡す
- **パラメータをメソッドで置換**：受信者がメソッドを自分で呼び出せる
- **パラメータオブジェクトの導入**：パラメータをオブジェクトにグループ化
- **設定メソッドの削除**：変更すべきでないフィールドのセッター削除
- **メソッドの隠蔽**：メソッドをプライベートに
- **コンストラクタをファクトリメソッドで置換**：コンストラクタをファクトリで置換
- **エラーコードを例外で置換**：エラーに例外使用
- **例外をテストで置換**：例外キャッチの代わりにテスト

#### 第11章：一般化の処理
**テーマ**：継承階層の上下での機能移動
- **フィールド/メソッドの引き上げ**：フィールド/メソッドをスーパークラスへ移動
- **フィールド/メソッドの押し下げ**：フィールド/メソッドをサブクラスへ移動
- **サブクラスの抽出**：機能サブセット用サブクラス作成
- **スーパークラスの抽出**：共有機能用スーパークラス作成
- **インターフェースの抽出**：プロトコルサブセット用インターフェース定義
- **階層の平坦化**：スーパークラスとサブクラスをマージ
- **テンプレートメソッドの形成**：テンプレートメソッドパターン作成
- **継承を委譲で置換**：継承の代わりに委譲使用
- **委譲を継承で置換**：委譲の代わりに継承使用

#### 第12章：大規模リファクタリング
**テーマ**：大規模構造変換
- **もつれた継承の解きほぐし**：もつれた継承階層を分割
- **手続き的設計をオブジェクトへ変換**：手続き的コードをOOへ変換
- **ドメインをプレゼンテーションから分離**：ビジネスロジックをUIから分離
- **階層の抽出**：条件ロジックを置換する階層作成

### 第III部：ゲスト寄稿（第13-15章）
**目的**：追加視点とより深い探求

#### 第13章：リファクタリング、再利用、現実（ウィリアム・オプダイク）
- **研究基礎**：リファクタリングの基礎となる学術研究
- **安全条件**：振る舞い保存の保証
- **ツールサポート要件**：ツールが提供すべきもの
- **実践的課題**：現実世界のリファクタリング問題

#### 第14章：リファクタリングツール（ドン・ロバーツとジョン・ブラント）
- **技術要件**：良いリファクタリングツールを作るもの
- **ユーザーインターフェース問題**：ツールがリファクタリングを提示すべき方法
- **リファクタリングブラウザ**：模範としてのSmalltalkツール
- **将来の方向**：ツーリングの向かう先

#### 第15章：すべてをまとめる（ケント・ベック）
- **実践でのリファクタリング**：現実世界での応用
- **リファクタリングとパターン**：設計パターンとの関係
- **リファクタリングの経済学**：いつ報われるか
- **文化的変化**：リファクタリングが開発を変える方法

## 構造的特徴と革新

### カタログ組織
- **階層構造**：意図によってグループ化されたリファクタリング
- **一貫した形式**：すべてのリファクタリングが同じテンプレートに従う
- **相互参照**：関連リファクタリング間の広範なリンク
- **逆ペア**：多くのリファクタリングには逆がある
- **複合リファクタリング**：単純から複雑を構築

### 例駆動学習
- **開始例**：理論前の完全な作業例
- **全体にわたるコード**：すべてのリファクタリングがコードで説明
- **段階的複雑性**：例が互いに構築
- **現実世界基盤**：実際のプロジェクトからの例

### ナビゲーションとリファレンス
- **複数インデックス**：名前別、臭い別、問題別
- **クイックリファレンス**：要約表とリスト
- **視覚的補助**：有用な場所でのUML図
- **明確なメカニクス**：段階的手順

## 教育戦略

### 学習パス設計
- **動機優先**：方法の前になぜ
- **具体から抽象へ**：原則前の例
- **実践指向**：実行の強調
- **リファレンス親和**：継続使用のための設計

### 複数聴衆
- **初心者**：例と原則から開始
- **実践者**：特定ニーズのためカタログへジャンプ
- **チームリード**：プロセスと採用に焦点
- **ツール構築者**：技術要件とメカニクス

### 知識構築
- **語彙開発**：共通言語確立
- **パターン認識**：問題への直感訓練
- **機械的スキル**：段階的手順
- **設計感覚**：良いコードへの味覚開発

## 革命的側面

### 体系的アプローチ
- **名前付き操作**：すべてのリファクタリングに名前
- **正確なメカニクス**：従うべき正確なステップ
- **安全重視**：振る舞い保存の強調
- **ツール認識**：自動化可能性の認識

### 文化的影響
- **クリーンアップの正当化**：改善を価値ある仕事に
- **継続的改善**：初期開発だけでなく
- **チームコミュニケーション**：議論のための共有語彙
- **品質基準**：コードへの期待向上

### プロセス統合
- **開発リズム**：フローの一部としてのリファクタリング
- **テスト駆動**：自信ある変更を可能にするテスト
- **漸進的設計**：リファクタリングを通じた設計
- **持続可能なペース**：コード健康の維持

## 歴史的意義

### タイミングと文脈
- **1999年出版**：OO革命の最高潮
- **XP運動**：アジャイル出現の一部
- **ツール進化**：IDEが成熟し始める
- **インターネット時代**：急速なソフトウェア進化ニーズ

### 永続的影響
- **標準実践**：リファクタリングは今や普遍的
- **ツール機能**：すべての主要IDEがリファクタリング持つ
- **教育的影響**：すべてのCSプログラムで教えられる
- **言語進化**：リファクタリング用に設計された言語

「リファクタリング」の構造は、マニフェストとマニュアル、教科書とリファレンス作品の両方としての二重性を反映している。具体例から原則を経て詳細カタログへの組織は非常に効果的であることが証明され、技術書のテンプレートとなった。一貫した形式と明確なメカニクスでのリファクタリングの体系的カタログ化は、アドホック実践を専門規律に変換し、開発者がコード改善にアプローチする方法を根本的に変えた。